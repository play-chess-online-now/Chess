<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Play chess online for free with friends or random players. Quick lobby, no registration required, and 100% free gameplay.">
    <meta name="keywords" content="chess online, multiplayer chess, play chess with friends, free chess game">
    <<title>Chess Fusion - Play Online with Friends for Free</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            padding: 20px;
        }
        .container { max-width: 1100px; width: 100%; }
        h1 {
            text-align: center;
            font-size: clamp(2rem, 5vw, 3rem);
            margin-bottom: 30px;
            text-shadow: 3px 3px 6px rgba(0,0,0,0.5);
        }
        .screen {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 40px;
            box-shadow: 0 10px 50px rgba(0,0,0,0.3);
            color: #333;
        }
        .hidden { display: none !important; }

        .info-box {
            background: #d4edda;
            border: 2px solid #28a745;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 20px;
            font-size: 0.95rem;
            color: #155724;
        }
        .info-box strong { display: block; margin-bottom: 5px; }

        .login-form { max-width: 500px; margin: 0 auto; }
        .login-form h2 {
            text-align: center;
            margin-bottom: 30px;
            color: #1e3c72;
            font-size: clamp(1.5rem, 4vw, 2rem);
        }

        .form-group { margin-bottom: 20px; }
        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
            font-size: 1.1rem;
            color: #1e3c72;
        }
        .form-group input,
        .form-group select {
            width: 100%;
            padding: 15px;
            font-size: 1.1rem;
            border: 3px solid #1e3c72;
            border-radius: 10px;
            outline: none;
        }
        .form-group input:focus,
        .form-group select:focus {
            border-color: #2a5298;
            box-shadow: 0 0 10px rgba(30, 60, 114, 0.3);
        }

        .form-inline {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }
        .form-inline label { margin-bottom: 0; }

        .error-message {
            color: #d32f2f;
            font-size: 0.95rem;
            margin-top: 8px;
            font-weight: bold;
        }

        .btn {
            width: 100%;
            padding: 18px;
            font-size: 1.3rem;
            font-weight: bold;
            background: #1e3c72;
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
            margin-top: 10px;
        }
        .btn:hover {
            background: #2a5298;
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(30, 60, 114, 0.4);
        }
        .btn:active { transform: translateY(0); }
        .btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }
        .btn-secondary { background: #6c757d; }
        .btn-secondary:hover { background: #5a6268; }

        .room-code-display {
            background: #fff3cd;
            border: 3px solid #ffc107;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
            text-align: center;
        }
        .room-code-display h3 { color: #856404; margin-bottom: 10px; }
        .room-code {
            font-size: 2rem;
            font-weight: bold;
            color: #1e3c72;
            letter-spacing: 3px;
            padding: 15px;
            background: white;
            border-radius: 8px;
            margin: 10px 0;
            user-select: all;
            word-break: break-all;
        }
        .copy-btn {
            padding: 10px 20px;
            background: #28a745;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            font-size: 1rem;
            margin-top: 10px;
        }
        .copy-btn:hover { background: #218838; }

        .lobby-layout {
            display: grid;
            grid-template-columns: 2fr 1.5fr;
            gap: 20px;
        }

        .lobby-options {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }
        .option-card {
            background: #f5f5f5;
            padding: 30px;
            border-radius: 15px;
            border: 3px solid #1e3c72;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
        }
        .option-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }
        .option-card h3 {
            color: #1e3c72;
            margin-bottom: 15px;
            font-size: 1.5rem;
        }
        .option-card p { color: #666; margin-bottom: 20px; }

        .waiting-room {
            background: #f5f5f5;
            padding: 30px;
            border-radius: 15px;
            border: 3px solid #1e3c72;
            text-align: center;
        }
        .waiting-room h3 { color: #1e3c72; margin-bottom: 20px; }

        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #1e3c72;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .online-panel {
            background: #f5f5f5;
            border-radius: 15px;
            border: 3px solid #1e3c72;
            padding: 20px;
            max-height: 420px;
            overflow-y: auto;
        }
        .online-panel h3 {
            color: #1e3c72;
            margin-bottom: 10px;
            text-align: center;
        }
        .online-panel small { display: block; text-align: center; color: #666; margin-bottom: 10px; }

        .player-list { list-style: none; margin-top: 10px; }
        .player-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 10px;
            margin-bottom: 6px;
            background: #ffffff;
            border-radius: 8px;
            border: 1px solid #ddd;
            font-size: 0.95rem;
        }
        .player-name { font-weight: bold; color: #1e3c72; }
        .player-status { font-size: 0.8rem; color: #666; margin-left: 5px; }
        .player-actions button {
            padding: 6px 10px;
            font-size: 0.85rem;
            border-radius: 6px;
            border: none;
            cursor: pointer;
            font-weight: bold;
        }
        .btn-invite { background: #28a745; color: #fff; }
        .btn-invite:hover { background: #218838; }
        .btn-disabled { background: #ccc; color: #666; cursor: not-allowed; }

        .invites-section { margin-top: 15px; border-top: 1px solid #ddd; padding-top: 10px; }
        .invite-item {
            background: #fff3cd;
            border: 1px solid #ffc107;
            border-radius: 8px;
            padding: 8px 10px;
            margin-bottom: 6px;
            font-size: 0.9rem;
        }
        .invite-buttons {
            margin-top: 6px;
            display: flex;
            gap: 6px;
        }
        .invite-btn {
            padding: 5px 8px;
            font-size: 0.8rem;
            border-radius: 6px;
            border: none;
            cursor: pointer;
            font-weight: bold;
        }
        .invite-accept { background: #28a745; color: #fff; }
        .invite-decline { background: #dc3545; color: #fff; }

        .game-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 15px;
        }
        .player-info {
            flex: 1;
            min-width: 200px;
            padding: 15px;
            background: #f5f5f5;
            border-radius: 10px;
            border: 3px solid #ddd;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        .player-info.active {
            border-color: #4caf50;
            background: #e8f5e9;
        }
        .player-info h3 {
            font-size: 1.1rem;
            color: #1e3c72;
            margin-bottom: 0;
        }
        .turn-indicator {
            font-size: 0.95rem;
            font-weight: bold;
            color: #4caf50;
        }
        .clock {
            font-size: 1.2rem;
            font-weight: bold;
            padding: 6px 10px;
            border-radius: 8px;
            display: inline-block;
            min-width: 80px;
            text-align: center;
        }
        .clock-active { background: #2e7d32; color: #fff; }
        .clock-inactive { background: #bdbdbd; color: #212121; }
        .clock-disabled { background: #eeeeee; color: #9e9e9e; }

        .game-controls {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        .btn-reset {
            padding: 12px 20px;
            font-size: 1rem;
            background: #ff5722;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
        }
        .btn-reset:hover { background: #e64a19; }
        .btn-leave {
            padding: 12px 20px;
            font-size: 1rem;
            background: #9e9e9e;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
        }
        .btn-leave:hover { background: #757575; }

        .chess-board-container {
            display: flex;
            justify-content: center;
            margin: 20px 0;
        }

        .side-clock {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            margin-right: 20px;
            gap: 20px;
        }
        .side-clock-time {
            font-size: 2.5rem;
            font-weight: bold;
            color: #000000;
            background: #ffffff;
            padding: 15px 25px;
            border-radius: 12px;
            border: 3px solid #333;
            min-width: 120px;
            text-align: center;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
        }
        .side-clock-time.active {
            border-color: #4caf50;
            background: #e8f5e9;
        }
        .side-clock-time.inactive { opacity: 0.6; }

        .chess-board {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 0;
            border: 5px solid #333;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            max-width: 600px;
            width: 100%;
            aspect-ratio: 1;
        }
        .square {
            aspect-ratio: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: clamp(2.5rem, 6vw, 4.5rem);
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
        }
        .square.light { background: #f5e2c4; }
        .square.dark { background: #8b5a2b; }
        .square.selected {
            background: #bae67e !important;
            box-shadow: inset 0 0 20px rgba(0,0,0,0.4);
        }
        .square.possible-move { background: #90ee90 !important; }
        .square.possible-move::after {
            content: '';
            position: absolute;
            width: 35%;
            height: 35%;
            background: rgba(76, 175, 80, 0.7);
            border-radius: 50%;
        }
        .square.possible-capture::after {
            content: '';
            position: absolute;
            width: 85%;
            height: 85%;
            border: 6px solid rgba(244, 67, 54, 0.8);
            border-radius: 50%;
            background: transparent;
        }
        .square:hover:not(.no-hover) { filter: brightness(1.15); }
        .square.no-hover { cursor: default; }

        .piece {
            user-select: none;
            font-weight: bold;
            filter: drop-shadow(0 0 6px rgba(0,0,0,0.8));
        }
        .piece.white {
            color: #ffffff;
            text-shadow: 0 0 4px rgba(0,0,0,1), 0 0 8px rgba(0,0,0,0.8);
        }
        .piece.black {
            color: #000000;
            text-shadow: 0 0 4px rgba(255,255,255,1), 0 0 8px rgba(255,255,255,0.8);
        }

        .status-message {
            text-align: center;
            font-size: 1.2rem;
            font-weight: bold;
            color: #1e3c72;
            margin-top: 20px;
            padding: 15px;
            background: #fff3cd;
            border-radius: 10px;
            border: 2px solid #ffc107;
        }
        .status-message.error {
            background: #f8d7da;
            border-color: #dc3545;
            color: #721c24;
        }

        .modal-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.6);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        .modal {
            background: #ffffff;
            color: #333;
            padding: 25px 30px;
            border-radius: 15px;
            max-width: 400px;
            width: 90%;
            box-shadow: 0 10px 40px rgba(0,0,0,0.4);
            text-align: center;
        }
        .modal h2 { margin-bottom: 15px; color: #1e3c72; }
        .modal p { margin-bottom: 20px; color: #555; }
        .modal-buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
            flex-wrap: wrap;
        }
        .modal-btn {
            padding: 10px 18px;
            border-radius: 8px;
            border: none;
            cursor: pointer;
            font-weight: bold;
            font-size: 1rem;
        }
        .modal-btn-primary { background: #1e3c72; color: #fff; }
        .modal-btn-primary:hover { background: #2a5298; }
        .modal-btn-secondary { background: #9e9e9e; color: #fff; }
        .modal-btn-secondary:hover { background: #757575; }
        .modal-info { font-size: 0.95rem; color: #777; margin-top: 10px; }

        .promotion-piece-btn {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            padding: 20px;
            background: #f5f5f5;
            border: 3px solid #1e3c72;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 1rem;
            font-weight: bold;
            color: #1e3c72;
        }
        .promotion-piece-btn:hover {
            background: #e8f5e9;
            border-color: #4caf50;
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }
        .promotion-piece {
            font-size: 3.5rem;
            filter: drop-shadow(0 0 6px rgba(0,0,0,0.8));
        }
        .promotion-piece.white {
            color: #ffffff;
            text-shadow: 0 0 4px rgba(0,0,0,1), 0 0 8px rgba(0,0,0,0.8);
        }
        .promotion-piece.black {
            color: #000000;
            text-shadow: 0 0 4px rgba(255,255,255,1), 0 0 8px rgba(255,255,255,0.8);
        }

        @media (max-width: 900px) {
            .screen { padding: 20px; }
            .lobby-layout { grid-template-columns: 1fr; }
            .lobby-options { grid-template-columns: 1fr; }
        }
        @media (max-width: 768px) {
            .game-info { flex-direction: column; align-items: stretch; }
            .game-controls { width: 100%; flex-direction: column; }
            .btn-reset, .btn-leave { width: 100%; }
            .chess-board-container { flex-direction: column; align-items: center; }
            .side-clock {
                flex-direction: row;
                margin-right: 0;
                margin-bottom: 15px;
            }
        }
    </style>
</head>
<body>
<div class="container">
    <h1>‚ôî Chess Online ‚ôö</h1>

    <!-- LOGIN -->
    <div id="loginScreen" class="screen">
        <div class="login-form">
            <div class="info-box">
                <strong>‚ú® Instant online chess on any device</strong>
                Play with friends using room codes or invite players from the online list.
            </div>
            <h2>Enter your nickname</h2>
            <div class="form-group">
                <label for="nicknameInput">Nickname:</label>
                <input type="text" id="nicknameInput" placeholder="Minimum 3 characters" maxlength="20">
                <div id="nicknameError" class="error-message hidden"></div>
            </div>
            <button class="btn" onclick="handleLogin()">Continue</button>
        </div>
    </div>

    <!-- LOBBY -->
    <div id="lobbyScreen" class="screen hidden">
        <h2 style="text-align: center; color: #1e3c72; margin-bottom: 20px;">
            Welcome, <span id="playerNickname"></span>!
        </h2>

        <div class="lobby-layout">
            <div>
                <div class="form-group" style="margin-bottom: 25px;">
                    <label>Game mode:</label>
                    <div class="form-inline">
                        <label>
                            <input type="radio" name="mode" id="modeNoTime" checked>
                            Without time
                        </label>
                        <label>
                            <input type="radio" name="mode" id="modeTimed">
                            With time
                        </label>
                        <select id="timeSelect" disabled>
                            <option value="5">5 minutes</option>
                            <option value="10">10 minutes</option>
                            <option value="15">15 minutes</option>
                            <option value="20">20 minutes</option>
                            <option value="30">30 minutes</option>
                            <option value="45">45 minutes</option>
                        </select>
                    </div>
                    <div style="font-size:0.9rem;color:#555;margin-top:5px;">
                        Time is per player, like in real tournament chess.
                    </div>
                </div>

                <div class="lobby-options">
                    <div class="option-card" onclick="createRoom()">
                        <h3>üéÆ Create Room</h3>
                        <p>Start a new game and share the room code.</p>
                        <button class="btn">Create</button>
                    </div>

                    <div class="option-card" onclick="showJoinForm()">
                        <h3>üîó Join Room</h3>
                        <p>Enter a room code to join a game.</p>
                        <button class="btn">Join</button>
                    </div>
                </div>

                <div id="joinForm" class="hidden" style="margin-top: 20px;">
                    <div class="form-group">
                        <label for="roomCodeInput">Room code:</label>
                        <input type="text" id="roomCodeInput" placeholder="Paste room code here">
                        <div id="joinError" class="error-message hidden"></div>
                    </div>
                    <button class="btn" onclick="joinRoom()">Join Game</button>
                </div>
            </div>

            <div class="online-panel">
                <h3>Players online</h3>
                <small>Click "Invite" to send a game request.</small>
                <ul id="onlinePlayersList" class="player-list"></ul>

                <div class="invites-section">
                    <h4 style="color:#1e3c72; margin-bottom:5px;">Incoming invites</h4>
                    <div id="invitesList"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- WAITING -->
    <div id="waitingScreen" class="screen hidden">
        <div class="waiting-room">
            <h3>üéÆ Waiting for opponent...</h3>
            <div class="room-code-display">
                <h3>Share this room code:</h3>
                <div class="room-code" id="roomCodeDisplay"></div>
                <button class="copy-btn" onclick="copyRoomCode()">üìã Copy code</button>
            </div>
            <div class="spinner"></div>
            <p style="color: #666; margin-top: 20px;">Send the room code or wait for an invited player to join.</p>
            <button class="btn btn-secondary" onclick="cancelWaiting()" style="max-width: 300px; margin: 20px auto;">Cancel</button>
        </div>
    </div>

    <!-- GAME -->
    <div id="gameScreen" class="screen hidden">
        <div class="game-info">
            <div class="player-info" id="whitePlayerInfo">
                <h3 id="whitePlayerName">‚ö™ White: ...</h3>
                <div class="turn-indicator" id="whiteTurnIndicator">Your turn!</div>
                <div id="whiteClock" class="clock clock-disabled">--:--</div>
            </div>
            <div class="game-controls">
                <button class="btn-reset" onclick="resetGame()">‚ôªÔ∏è Reset</button>
                <button class="btn-leave" onclick="leaveGame()">üö™ Leave</button>
            </div>
            <div class="player-info" id="blackPlayerInfo">
                <h3 id="blackPlayerName">‚ö´ Black: ...</h3>
                <div class="turn-indicator" id="blackTurnIndicator">Your turn!</div>
                <div id="blackClock" class="clock clock-disabled">--:--</div>
            </div>
        </div>

        <div class="chess-board-container">
            <div class="side-clock">
                <div id="sideClockWhite" class="side-clock-time">--:--</div>
                <div id="sideClockBlack" class="side-clock-time">--:--</div>
            </div>
            <div id="chessBoard" class="chess-board"></div>
        </div>

        <div id="statusMessage" class="status-message hidden"></div>
    </div>
    <!-- WINNER MODAL -->
    <div id="winnerOverlay" class="modal-overlay hidden">
        <div class="modal">
            <h2>üéâ Congratulations!</h2>
            <p>You won this game. You can offer a rematch to your opponent.</p>
            <div class="modal-buttons">
                <button class="modal-btn modal-btn-primary" onclick="sendRematchOffer()">Offer rematch</button>
                <button class="modal-btn modal-btn-secondary" onclick="closeWinnerModal()">Close</button>
            </div>
            <div id="winnerModalInfo" class="modal-info"></div>
        </div>
    </div>

    <!-- LOSER MODAL -->
    <div id="loserOverlay" class="modal-overlay hidden">
        <div class="modal">
            <h2>Good game!</h2>
            <p>You lost this game, but your opponent offers a rematch. Do you want to play again?</p>
            <div class="modal-buttons">
                <button class="modal-btn modal-btn-primary" onclick="respondRematch(true)">Yes, play again</button>
                <button class="modal-btn modal-btn-secondary" onclick="respondRematch(false)">No, I'm done</button>
            </div>
        </div>
    </div>

    <!-- PROMOTION MODAL -->
    <div id="promotionOverlay" class="modal-overlay hidden">
        <div class="modal">
            <h2>üéâ Pawn Promotion!</h2>
            <p>Choose which piece your pawn should become:</p>
            <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 15px; margin-top: 20px;">
                <button class="promotion-piece-btn" onclick="selectPromotion('queen')">
                    <span class="promotion-piece" id="promotionQueen">‚ôï</span>
                    <span>Queen</span>
                </button>
                <button class="promotion-piece-btn" onclick="selectPromotion('rook')">
                    <span class="promotion-piece" id="promotionRook">‚ôñ</span>
                    <span>Rook</span>
                </button>
                <button class="promotion-piece-btn" onclick="selectPromotion('bishop')">
                    <span class="promotion-piece" id="promotionBishop">‚ôó</span>
                    <span>Bishop</span>
                </button>
                <button class="promotion-piece-btn" onclick="selectPromotion('knight')">
                    <span class="promotion-piece" id="promotionKnight">‚ôò</span>
                    <span>Knight</span>
                </button>
            </div>
        </div>
    </div>
</div>

<!-- PeerJS -->
<script src="https://unpkg.com/peerjs@1.5.1/dist/peerjs.min.js"></script>

<!-- Firebase v8 (Realtime Database) -->
<script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
<script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-database.js"></script>

<script>
    const firebaseConfig = {
      apiKey: "AIzaSyC6U1YIf3MF09lsEmzK0-rzAGXOzws4y6M",
      authDomain: "chess-play-online.firebaseapp.com",
      databaseURL: "https://chess-play-online-default-rtdb.europe-west1.firebasedatabase.app",
      projectId: "chess-play-online",
      storageBucket: "chess-play-online.appspot.com",
      messagingSenderId: "804176056040",
      appId: "1:804176056040:web:70933719609cb1b072835d"
    };
    firebase.initializeApp(firebaseConfig);
    const db = firebase.database();

    let currentPlayer = null;
    let playerId = null;
    let playerRef = null;
    let playersRef = db.ref('players');
    let invitesRef = null;

    let peer = null;
    let connection = null;
    let myColor = null;
    let gameState = null;
    let isHost = false;
    let selectedSquare = null;
    let possibleMoves = [];
    let isGameOver = false;
    let lastWinnerName = null;
    let pendingRematchFromWinner = null;

    let pendingPromotion = null; // {fromRow, fromCol, toRow, toCol}

    let timedGame = false;
    let timePerMinutes = 0;
    let whiteTimeMs = 0;
    let blackTimeMs = 0;
    let activeTimer = null;
    let lastTickTime = null;

    const pieces = {
        white: { king: '‚ôî', queen: '‚ôï', rook: '‚ôñ', bishop: '‚ôó', knight: '‚ôò', pawn: '‚ôô' },
        black: { king: '‚ôö', queen: '‚ôõ', rook: '‚ôú', bishop: '‚ôù', knight: '‚ôû', pawn: '‚ôü' }
    };

    function getInitialBoard() {
        return [
            ['‚ôú', '‚ôû', '‚ôù', '‚ôõ', '‚ôö', '‚ôù', '‚ôû', '‚ôú'],
            ['‚ôü', '‚ôü', '‚ôü', '‚ôü', '‚ôü', '‚ôü', '‚ôü', '‚ôü'],
            ['', '', '', '', '', '', '', ''],
            ['', '', '', '', '', '', '', ''],
            ['', '', '', '', '', '', '', ''],
            ['', '', '', '', '', '', '', ''],
            ['‚ôô', '‚ôô', '‚ôô', '‚ôô', '‚ôô', '‚ôô', '‚ôô', '‚ôô'],
            ['‚ôñ', '‚ôò', '‚ôó', '‚ôï', '‚ôî', '‚ôó', '‚ôò', '‚ôñ']
        ];
    }

    function createInitialCastlingState() {
        return {
            whiteKingMoved: false,
            blackKingMoved: false,
            whiteRookLeftMoved: false,
            whiteRookRightMoved: false,
            blackRookLeftMoved: false,
            blackRookRightMoved: false
        };
    }

    function handleLogin() {
        const input = document.getElementById('nicknameInput');
        const nickname = input.value.trim();
        const errorDiv = document.getElementById('nicknameError');
        if (nickname.length < 3) {
            errorDiv.textContent = 'Nickname must be at least 3 characters!';
            errorDiv.classList.remove('hidden');
            return;
        }
        currentPlayer = nickname;
        errorDiv.classList.add('hidden');
        setupPresence();
        showLobby();
    }

    function setupPresence() {
        playerId = localStorage.getItem('chess_player_id') || 'p-' + Math.random().toString(36).substr(2, 9);
        localStorage.setItem('chess_player_id', playerId);
        if (playerRef) playerRef.remove();
        playerRef = playersRef.child(playerId);
        invitesRef = db.ref('invites/' + playerId);
        
        playerRef.onDisconnect().remove();
        window.onbeforeunload = function() {
            playerRef.remove();
        };

        playerRef.set({
            nickname: currentPlayer,
            status: 'online',
            inGame: false,
            lastActive: firebase.database.ServerValue.TIMESTAMP
        });

        playersRef.on('value', snapshot => {
            const players = snapshot.val() || {};
            renderOnlinePlayers(players);
        });

        invitesRef.on('value', snapshot => {
            const invites = snapshot.val() || {};
            renderInvites(invites);
        });
    }

    function showLobby() {
        document.getElementById('loginScreen').classList.add('hidden');
        document.getElementById('lobbyScreen').classList.remove('hidden');
        document.getElementById('playerNickname').textContent = currentPlayer;
    }

    function showJoinForm() {
        document.getElementById('joinForm').classList.remove('hidden');
    }

    document.addEventListener('DOMContentLoaded', () => {
        const modeNoTime = document.getElementById('modeNoTime');
        const modeTimed = document.getElementById('modeTimed');
        const timeSelect = document.getElementById('timeSelect');

        function updateTimeSelect() {
            timeSelect.disabled = !modeTimed.checked;
        }

        modeNoTime.addEventListener('change', updateTimeSelect);
        modeTimed.addEventListener('change', updateTimeSelect);
        updateTimeSelect();
    });

    function renderOnlinePlayers(players) {
        const list = document.getElementById('onlinePlayersList');
        list.innerHTML = '';
        Object.keys(players).forEach(id => {
            if (id === playerId) return;
            const p = players[id];
	    if (!p.nickname) return;
            const li = document.createElement('li');
            li.className = 'player-item';

            const left = document.createElement('div');
            const nameSpan = document.createElement('span');
            nameSpan.className = 'player-name';
            nameSpan.textContent = p.nickname || 'Unknown';

            const statusSpan = document.createElement('span');
            statusSpan.className = 'player-status';
            statusSpan.textContent = p.inGame ? '(in game)' : '(available)';

            left.appendChild(nameSpan);
            left.appendChild(statusSpan);

            const right = document.createElement('div');
            right.className = 'player-actions';
            const btn = document.createElement('button');

            if (p.inGame) {
                btn.textContent = 'Busy';
                btn.className = 'btn-disabled';
                btn.disabled = true;
            } else {
                btn.textContent = 'Invite';
                btn.className = 'btn-invite';
                btn.onclick = () => invitePlayer(id, p.nickname);
            }

            right.appendChild(btn);
            li.appendChild(left);
            li.appendChild(right);
            list.appendChild(li);
        });
    }

    function renderInvites(invites) {
        const container = document.getElementById('invitesList');
        container.innerHTML = '';
        Object.keys(invites).forEach(inviteId => {
            const inv = invites[inviteId];
            const div = document.createElement('div');
            div.className = 'invite-item';
            div.innerHTML = `<strong>${inv.fromName}</strong> invites you to play.`;

            const btns = document.createElement('div');
            btns.className = 'invite-buttons';

            const acceptBtn = document.createElement('button');
            acceptBtn.className = 'invite-btn invite-accept';
            acceptBtn.textContent = 'Accept';
            acceptBtn.onclick = () => acceptInvite(inviteId, inv);

            const declineBtn = document.createElement('button');
            declineBtn.className = 'invite-btn invite-decline';
            declineBtn.textContent = 'Decline';
            declineBtn.onclick = () => declineInvite(inviteId);

            btns.appendChild(acceptBtn);
            btns.appendChild(declineBtn);
            div.appendChild(btns);
            container.appendChild(div);
        });
    }

    function invitePlayer(targetId, targetName) {
        const modeNoTime = document.getElementById('modeNoTime');
        const modeTimed = document.getElementById('modeTimed');
        const timeSelect = document.getElementById('timeSelect');

        timedGame = modeTimed.checked;
        timePerMinutes = timedGame ? parseInt(timeSelect.value, 10) : 0;

        isHost = true;
        myColor = 'white';

        const roomId = 'chess-' + Math.random().toString(36).substr(2, 9);
        peer = new Peer(roomId);
        peer.on('open', (id) => {
            const initialBoard = getInitialBoard();
            const initialCastling = createInitialCastlingState();
            const initialTimeMs = timedGame ? timePerMinutes * 60 * 1000 : 0;

            gameState = {
                white: currentPlayer,
                black: targetName,
                board: initialBoard,
                currentTurn: 'white',
                timedGame: timedGame,
                timeMinutes: timePerMinutes,
                whiteTimeMs: initialTimeMs,
                blackTimeMs: initialTimeMs,
                ...initialCastling
            };

            whiteTimeMs = initialTimeMs;
            blackTimeMs = initialTimeMs;

            const inviteRef = db.ref('invites/' + targetId).push();
            inviteRef.set({
                fromId: playerId,
                fromName: currentPlayer,
                roomId: id,
                timedGame: timedGame,
                timeMinutes: timePerMinutes,
                timestamp: firebase.database.ServerValue.TIMESTAMP
            });

            playerRef.update({ inGame: true });
            document.getElementById('lobbyScreen').classList.add('hidden');
            document.getElementById('waitingScreen').classList.remove('hidden');
            document.getElementById('roomCodeDisplay').textContent = id;

            peer.on('connection', (conn) => {
                connection = conn;
                setupConnection();
            });
            peer.on('error', (err) => {
                console.error('Peer error:', err);
                showStatus('Connection error!', true);
            });
        });
    }

    function acceptInvite(inviteId, invite) {
        if (!invite || !invite.roomId) return;
        invitesRef.child(inviteId).remove();

        isHost = false;
        myColor = 'black';

        timedGame = !!invite.timedGame;
        timePerMinutes = invite.timeMinutes || 0;

        peer = new Peer();
        peer.on('open', () => {
            connection = peer.connect(invite.roomId);
            setupConnection();
        });
        peer.on('error', (err) => {
            console.error('Peer error:', err);
            showStatus('Connection error while accepting invite!', true);
        });

        playerRef.update({ inGame: true });
        document.getElementById('lobbyScreen').classList.add('hidden');
        document.getElementById('waitingScreen').classList.remove('hidden');
        document.getElementById('roomCodeDisplay').textContent = invite.roomId;
    }

    function declineInvite(inviteId) {
        invitesRef.child(inviteId).remove();
    }

    function createRoom() {
        const modeNoTime = document.getElementById('modeNoTime');
        const modeTimed = document.getElementById('modeTimed');
        const timeSelect = document.getElementById('timeSelect');

        timedGame = modeTimed.checked;
        timePerMinutes = timedGame ? parseInt(timeSelect.value, 10) : 0;

        isHost = true;
        myColor = 'white';
        const roomId = 'chess-' + Math.random().toString(36).substr(2, 9);
        peer = new Peer(roomId);
        peer.on('open', (id) => {
            const initialBoard = getInitialBoard();
            const initialCastling = createInitialCastlingState();
            const initialTimeMs = timedGame ? timePerMinutes * 60 * 1000 : 0;

            gameState = {
                white: currentPlayer,
                black: '',
                board: initialBoard,
                currentTurn: 'white',
                timedGame: timedGame,
                timeMinutes: timePerMinutes,
                whiteTimeMs: initialTimeMs,
                blackTimeMs: initialTimeMs,
                ...initialCastling
            };

            whiteTimeMs = initialTimeMs;
            blackTimeMs = initialTimeMs;

            playerRef.update({ inGame: true });

            document.getElementById('lobbyScreen').classList.add('hidden');
            document.getElementById('waitingScreen').classList.remove('hidden');
            document.getElementById('roomCodeDisplay').textContent = id;
        });
        peer.on('connection', (conn) => {
            connection = conn;
            setupConnection();
        });
        peer.on('error', (err) => {
            console.error('Peer error:', err);
            showStatus('Connection error!', true);
        });
    }

    function joinRoom() {
        const roomCode = document.getElementById('roomCodeInput').value.trim();
        const errorDiv = document.getElementById('joinError');
        if (!roomCode) {
            errorDiv.textContent = 'Please enter a room code!';
            errorDiv.classList.remove('hidden');
            return;
        }
        isHost = false;
        myColor = 'black';
        peer = new Peer();
        peer.on('open', () => {
            connection = peer.connect(roomCode);
            setupConnection();
        });
        peer.on('error', (err) => {
            console.error('Peer error:', err);
            errorDiv.textContent = 'Invalid room code or connection error!';
            errorDiv.classList.remove('hidden');
        });
    }

    function setupConnection() {
        connection.on('open', () => {
            if (isHost) {
                connection.send({
                    type: 'start',
                    gameState: gameState
                });
                startGame();
            } else {
                connection.send({
                    type: 'join',
                    nickname: currentPlayer
                });
            }
        });
        connection.on('data', (data) => {
            handleMessage(data);
        });
        connection.on('close', () => {
            showStatus('Opponent disconnected!', true);
            stopClock();
            playerRef.update({ inGame: false });
            setTimeout(() => {
                leaveGame(true);
            }, 2000);
        });
        connection.on('error', (err) => {
            console.error('Connection error:', err);
            showStatus('Connection error!', true);
        });
    }

    function handleMessage(data) {
        switch (data.type) {
            case 'join':
                gameState.black = data.nickname;
                connection.send({
                    type: 'start',
                    gameState: gameState
                });
                startGame();
                break;
            case 'start':
                gameState = data.gameState;
                timedGame = !!gameState.timedGame;
                timePerMinutes = gameState.timeMinutes || 0;
                whiteTimeMs = gameState.whiteTimeMs || (timedGame ? timePerMinutes * 60 * 1000 : 0);
                blackTimeMs = gameState.blackTimeMs || (timedGame ? timePerMinutes * 60 * 1000 : 0);
                startGame();
                break;
            case 'move':
                gameState.board = data.board;
                gameState.currentTurn = data.currentTurn;
                if (data.castling) {
                    gameState.whiteKingMoved = data.castling.whiteKingMoved;
                    gameState.blackKingMoved = data.castling.blackKingMoved;
                    gameState.whiteRookLeftMoved = data.castling.whiteRookLeftMoved;
                    gameState.whiteRookRightMoved = data.castling.whiteRookRightMoved;
                    gameState.blackRookLeftMoved = data.castling.blackRookLeftMoved;
                    gameState.blackRookRightMoved = data.castling.blackRookRightMoved;
                }
                if (timedGame && data.time) {
                    whiteTimeMs = data.time.whiteTimeMs;
                    blackTimeMs = data.time.blackTimeMs;
                }
                updateGameUI();
                if (!isGameOver) {
                    startClockForCurrentTurn();
                }
                break;
            case 'reset':
                gameState.board = getInitialBoard();
                gameState.currentTurn = 'white';
                Object.assign(gameState, createInitialCastlingState());
                timedGame = !!gameState.timedGame;
                timePerMinutes = gameState.timeMinutes || 0;
                whiteTimeMs = timedGame ? timePerMinutes * 60 * 1000 : 0;
                blackTimeMs = timedGame ? timePerMinutes * 60 * 1000 : 0;
                isGameOver = false;
                selectedSquare = null;
                possibleMoves = [];
                stopClock();
                updateGameUI();
                if (timedGame) startClockForCurrentTurn();
                showStatus('Game reset!');
                break;
            case 'gameOver':
                lastWinnerName = data.winnerName;
                stopClock();
                handleGameOver(data.winnerColor, false);
                break;
            case 'rematchOffer':
                pendingRematchFromWinner = data.winnerName;
                openLoserModal();
                break;
            case 'rematchResponse':
                handleRematchResponse(data.accepted, data.winnerName);
                break;
            case 'newRound':
                gameState.white = data.whiteName;
                gameState.black = data.blackName;
                gameState.board = getInitialBoard();
                gameState.currentTurn = 'white';
                timedGame = !!data.timedGame;
                timePerMinutes = data.timeMinutes || 0;
                gameState.timedGame = timedGame;
                gameState.timeMinutes = timePerMinutes;
                whiteTimeMs = timedGame ? timePerMinutes * 60 * 1000 : 0;
                blackTimeMs = timedGame ? timePerMinutes * 60 * 1000 : 0;
                myColor = (currentPlayer === data.whiteName) ? 'white' : 'black';
                Object.assign(gameState, createInitialCastlingState());
                isGameOver = false;
                selectedSquare = null;
                possibleMoves = [];
                closeWinnerModal();
                closeLoserModal();
                stopClock();
                showStatus('New round started!');
                updateGameUI();
                if (timedGame) startClockForCurrentTurn();
                break;
        }
    }

    function startGame() {
        document.getElementById('waitingScreen').classList.add('hidden');
        document.getElementById('lobbyScreen').classList.add('hidden');
        document.getElementById('gameScreen').classList.remove('hidden');
        isGameOver = false;
        selectedSquare = null;
        possibleMoves = [];
        stopClock();
        updateGameUI();
        if (timedGame) {
            if (!whiteTimeMs && !blackTimeMs) {
                whiteTimeMs = timePerMinutes * 60 * 1000;
                blackTimeMs = timePerMinutes * 60 * 1000;
            }
            startClockForCurrentTurn();
        }
    }

    function toRealCoords(row, col) {
        if (myColor === 'white') return { row, col };
        return { row: 7 - row, col: 7 - col };
    }

    function updateGameUI() {
        document.getElementById('whitePlayerName').textContent = `‚ö™ White: ${gameState.white}`;
        document.getElementById('blackPlayerName').textContent = `‚ö´ Black: ${gameState.black}`;

        const whiteInfo = document.getElementById('whitePlayerInfo');
        const blackInfo = document.getElementById('blackPlayerInfo');
        const whiteIndicator = document.getElementById('whiteTurnIndicator');
        const blackIndicator = document.getElementById('blackTurnIndicator');
        const whiteClockEl = document.getElementById('whiteClock');
        const blackClockEl = document.getElementById('blackClock');

        if (gameState.currentTurn === 'white') {
            whiteInfo.classList.add('active');
            blackInfo.classList.remove('active');
            whiteIndicator.classList.remove('hidden');
            blackIndicator.classList.add('hidden');
        } else {
            blackInfo.classList.add('active');
            whiteInfo.classList.remove('active');
            blackIndicator.classList.remove('hidden');
            whiteIndicator.classList.add('hidden');
        }

        if (timedGame) {
            whiteClockEl.textContent = formatTime(whiteTimeMs);
            blackClockEl.textContent = formatTime(blackTimeMs);
            whiteClockEl.className = 'clock ' + (gameState.currentTurn === 'white' && !isGameOver ? 'clock-active' : 'clock-inactive');
            blackClockEl.className = 'clock ' + (gameState.currentTurn === 'black' && !isGameOver ? 'clock-active' : 'clock-inactive');
        } else {
            whiteClockEl.textContent = '--:--';
            blackClockEl.textContent = '--:--';
            whiteClockEl.className = 'clock clock-disabled';
            blackClockEl.className = 'clock clock-disabled';
        }

        const sideWhite = document.getElementById('sideClockWhite');
        const sideBlack = document.getElementById('sideClockBlack');
        if (timedGame) {
            sideWhite.textContent = formatTime(whiteTimeMs);
            sideBlack.textContent = formatTime(blackTimeMs);

            if (gameState.currentTurn === 'white' && !isGameOver) {
                sideWhite.classList.add('active');
                sideWhite.classList.remove('inactive');
                sideBlack.classList.add('inactive');
                sideBlack.classList.remove('active');
            } else if (gameState.currentTurn === 'black' && !isGameOver) {
                sideBlack.classList.add('active');
                sideBlack.classList.remove('inactive');
                sideWhite.classList.add('inactive');
                sideWhite.classList.remove('active');
            } else {
                sideWhite.classList.remove('active');
                sideBlack.classList.remove('active');
                sideWhite.classList.add('inactive');
                sideBlack.classList.add('inactive');
            }
        } else {
            sideWhite.textContent = '--:--';
            sideBlack.textContent = '--:--';
            sideWhite.classList.remove('active', 'inactive');
            sideBlack.classList.remove('active', 'inactive');
        }

        renderBoard();
    }

    function renderBoard() {
        const boardDiv = document.getElementById('chessBoard');
        boardDiv.innerHTML = '';

        const canPlayNow = !isGameOver && gameState && myColor && gameState.currentTurn === myColor;

        for (let displayRow = 0; displayRow < 8; displayRow++) {
            for (let displayCol = 0; displayCol < 8; displayCol++) {
                const { row, col } = toRealCoords(displayRow, displayCol);
                const square = document.createElement('div');
                square.className = 'square';
                square.className += (displayRow + displayCol) % 2 === 0 ? ' light' : ' dark';

                const piece = gameState.board[row][col];
                if (piece) {
                    const isWhitePiece = Object.values(pieces.white).includes(piece);
                    const pieceColorClass = isWhitePiece ? 'white' : 'black';
                    square.innerHTML = `<span class="piece ${pieceColorClass}">${piece}</span>`;
                }

                if (selectedSquare && selectedSquare.row === row && selectedSquare.col === col) {
                    square.classList.add('selected');
                }

                const isPossibleMove = possibleMoves.some(m => m.row === row && m.col === col);
                if (isPossibleMove) {
                    square.classList.add('possible-move');
                    if (gameState.board[row][col]) {
                        square.classList.add('possible-capture');
                    }
                }

                if (canPlayNow) {
                    square.onclick = () => handleSquareClick(row, col);
                } else {
                    square.classList.add('no-hover');
                }

                boardDiv.appendChild(square);
            }
        }
    }

    function handleSquareClick(row, col) {
        if (!gameState || isGameOver) return;
        if (gameState.currentTurn !== myColor) return;

        const piece = gameState.board[row][col];
        const isPossibleMove = possibleMoves.some(m => m.row === row && m.col === col);

        // Je≈õli klikniƒôto mo≈ºliwy ruch (w tym bicie)
        if (isPossibleMove && selectedSquare) {
            makeMove(selectedSquare.row, selectedSquare.col, row, col);
            selectedSquare = null;
            possibleMoves = [];
            return;
        }

        // Je≈õli klikniƒôto w≈ÇasnƒÖ figurƒô - zaznacz jƒÖ
        if (piece && canSelectPiece(piece)) {
            selectedSquare = { row, col };
            possibleMoves = getPossibleMoves(row, col, piece);
            renderBoard();
        } else {
            // Klikniƒôto puste pole lub figurƒô przeciwnika (nie w ramach mo≈ºliwego ruchu)
            selectedSquare = null;
            possibleMoves = [];
            renderBoard();
        }
    }

    function canSelectPiece(piece) {
        const whitePieces = Object.values(pieces.white);
        const blackPieces = Object.values(pieces.black);

        if (myColor === 'white') {
            return whitePieces.includes(piece);
        } else {
            return blackPieces.includes(piece);
        }
    }

    function makeMove(fromRow, fromCol, toRow, toCol, promotionPiece = null) {
        if (isGameOver) return;
        const piece = gameState.board[fromRow][fromCol];
        const isWhite = Object.values(pieces.white).includes(piece);

        // Check if this is a pawn promotion move
        const isWhitePawn = piece === pieces.white.pawn;
        const isBlackPawn = piece === pieces.black.pawn;
        const needsPromotion = (isWhitePawn && toRow === 0) || (isBlackPawn && toRow === 7);

        if (needsPromotion && !promotionPiece) {
            // Save the move and show promotion modal
            pendingPromotion = { fromRow, fromCol, toRow, toCol };
            showPromotionModal(isWhite);
            return;
        }

        if (timedGame) {
            updateTimeForCurrentTurn();
            stopClock();
        }

        let isCastlingMove = false;

        if (piece === pieces.white.king) {
            gameState.whiteKingMoved = true;
            if (fromRow === 7 && fromCol === 4 && toRow === 7 && toCol === 6) {
                gameState.board[7][5] = gameState.board[7][7];
                gameState.board[7][7] = '';
                isCastlingMove = true;
            } else if (fromRow === 7 && fromCol === 4 && toRow === 7 && toCol === 2) {
                gameState.board[7][3] = gameState.board[7][0];
                gameState.board[7][0] = '';
                isCastlingMove = true;
            }
        } else if (piece === pieces.black.king) {
            gameState.blackKingMoved = true;
            if (fromRow === 0 && fromCol === 4 && toRow === 0 && toCol === 6) {
                gameState.board[0][5] = gameState.board[0][7];
                gameState.board[0][7] = '';
                isCastlingMove = true;
            } else if (fromRow === 0 && fromCol === 4 && toRow === 0 && toCol === 2) {
                gameState.board[0][3] = gameState.board[0][0];
                gameState.board[0][0] = '';
                isCastlingMove = true;
            }
        }

        if (piece === pieces.white.rook) {
            if (fromRow === 7 && fromCol === 0) gameState.whiteRookLeftMoved = true;
            if (fromRow === 7 && fromCol === 7) gameState.whiteRookRightMoved = true;
        } else if (piece === pieces.black.rook) {
            if (fromRow === 0 && fromCol === 0) gameState.blackRookLeftMoved = true;
            if (fromRow === 0 && fromCol === 7) gameState.blackRookRightMoved = true;
        }

        gameState.board[toRow][toCol] = piece;
        gameState.board[fromRow][fromCol] = '';

        // Handle pawn promotion
        if (needsPromotion && promotionPiece) {
            const promotedPiece = isWhite ? pieces.white[promotionPiece] : pieces.black[promotionPiece];
            gameState.board[toRow][toCol] = promotedPiece;
            const pieceNames = { queen: 'Queen', rook: 'Rook', bishop: 'Bishop', knight: 'Knight' };
            showStatus(`Pawn promoted to ${pieceNames[promotionPiece]}! ${promotedPiece}`);
        }

        gameState.currentTurn = gameState.currentTurn === 'white' ? 'black' : 'white';

        const winnerColor = checkGameStatusAndReturnWinner();

        const moveMessage = {
            type: 'move',
            board: gameState.board,
            currentTurn: gameState.currentTurn,
            castling: {
                whiteKingMoved: gameState.whiteKingMoved,
                blackKingMoved: gameState.blackKingMoved,
                whiteRookLeftMoved: gameState.whiteRookLeftMoved,
                whiteRookRightMoved: gameState.whiteRookRightMoved,
                blackRookLeftMoved: gameState.blackRookLeftMoved,
                blackRookRightMoved: gameState.blackRookRightMoved
            }
        };

        if (timedGame) {
            moveMessage.time = {
                whiteTimeMs: whiteTimeMs,
                blackTimeMs: blackTimeMs
            };
        }

        if (connection && connection.open) {
            connection.send(moveMessage);
        }

        updateGameUI();

        if (winnerColor) {
            const winnerName = winnerColor === 'white' ? gameState.white : gameState.black;
            lastWinnerName = winnerName;
            if (connection && connection.open) {
                connection.send({
                    type: 'gameOver',
                    winnerColor: winnerColor,
                    winnerName: winnerName
                });
            }
            handleGameOver(winnerColor, true);
        } else if (timedGame) {
            startClockForCurrentTurn();
        }
    }

    function checkGameStatusAndReturnWinner() {
        const currentIsWhite = gameState.currentTurn === 'white';
        const kingPiece = currentIsWhite ? pieces.white.king : pieces.black.king;
        let kingRow, kingCol;
        for (let r = 0; r < 8; r++) {
            for (let c = 0; c < 8; c++) {
                if (gameState.board[r][c] === kingPiece) {
                    kingRow = r;
                    kingCol = c;
                    break;
                }
            }
            if (kingRow !== undefined) break;
        }
        const inCheck = isSquareUnderAttack(kingRow, kingCol, !currentIsWhite, gameState.board);
        if (inCheck) {
            let hasLegalMove = false;
            const myPieces = currentIsWhite ? Object.values(pieces.white) : Object.values(pieces.black);
            outerLoop:
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const piece = gameState.board[r][c];
                    if (myPieces.includes(piece)) {
                        const moves = getPossibleMoves(r, c, piece);
                        if (moves.length > 0) {
                            hasLegalMove = true;
                            break outerLoop;
                        }
                    }
                }
            }
            if (!hasLegalMove) {
                const winnerColor = currentIsWhite ? 'black' : 'white';
                showStatus(`CHECKMATE! ${winnerColor === 'white' ? 'White' : 'Black'} wins! üèÜ`, true);
                return winnerColor;
            } else {
                showStatus('CHECK! ‚ö†Ô∏è', true);
            }
        }
        return null;
    }

    function handleGameOver(winnerColor, isInitiator) {
        isGameOver = true;
        selectedSquare = null;
        possibleMoves = [];
        stopClock();
        const winnerName = winnerColor === 'white' ? gameState.white : gameState.black;
        const loserName = winnerColor === 'white' ? gameState.black : gameState.white;
        if (currentPlayer === winnerName) {
            showStatus('You won this game! üéâ');
            openWinnerModal();
        } else if (currentPlayer === loserName) {
            showStatus('You lost this game. Good fight!', true);
        }
        updateGameUI();
    }

    function getPossibleMoves(row, col, piece) {
        const moves = [];
        const isWhite = Object.values(pieces.white).includes(piece);
        const board = gameState.board;

        if (piece === pieces.white.pawn || piece === pieces.black.pawn) {
            const direction = isWhite ? -1 : 1;
            const startRow = isWhite ? 6 : 1;
            const nextRow = row + direction;
            if (nextRow >= 0 && nextRow < 8 && board[nextRow][col] === '') {
                moves.push({ row: nextRow, col });
                const doubleRow = row + (2 * direction);
                if (row === startRow && board[doubleRow][col] === '') {
                    moves.push({ row: doubleRow, col });
                }
            }
            [-1, 1].forEach(dc => {
                const captureCol = col + dc;
                if (nextRow >= 0 && nextRow < 8 && captureCol >= 0 && captureCol < 8) {
                    const targetPiece = board[nextRow][captureCol];
                    if (targetPiece && isOpponentPiece(targetPiece, isWhite)) {
                        moves.push({ row: nextRow, col: captureCol });
                    }
                }
            });
        } else if (piece === pieces.white.rook || piece === pieces.black.rook) {
            addLineMoves(row, col, [
                [0, 1],
                [0, -1],
                [1, 0],
                [-1, 0]
            ], moves, isWhite, board);
        } else if (piece === pieces.white.bishop || piece === pieces.black.bishop) {
            addLineMoves(row, col, [
                [1, 1],
                [1, -1],
                [-1, 1],
                [-1, -1]
            ], moves, isWhite, board);
        } else if (piece === pieces.white.queen || piece === pieces.black.queen) {
            addLineMoves(row, col, [
                [0, 1], [0, -1], [1, 0], [-1, 0],
                [1, 1], [1, -1], [-1, 1], [-1, -1]
            ], moves, isWhite, board);
        } else if (piece === pieces.white.knight || piece === pieces.black.knight) {
            const knightMoves = [
                [-2, -1], [-2, 1],
                [-1, -2], [-1, 2],
                [1, -2], [1, 2],
                [2, -1], [2, 1]
            ];
            knightMoves.forEach(([dr, dc]) => {
                const newRow = row + dr;
                const newCol = col + dc;
                if (isValidSquare(newRow, newCol)) {
                    const target = board[newRow][newCol];
                    if (!target || isOpponentPiece(target, isWhite)) {
                        moves.push({ row: newRow, col: newCol });
                    }
                }
            });
        } else if (piece === pieces.white.king || piece === pieces.black.king) {
            const kingMoves = [
                [-1, -1], [-1, 0], [-1, 1],
                [0, -1],           [0, 1],
                [1, -1],  [1, 0],  [1, 1]
            ];
            kingMoves.forEach(([dr, dc]) => {
                const newRow = row + dr;
                const newCol = col + dc;
                if (isValidSquare(newRow, newCol)) {
                    const target = board[newRow][newCol];
                    if (!target || isOpponentPiece(target, isWhite)) {
                        moves.push({ row: newRow, col: newCol });
                    }
                }
            });

            const isWhiteKing = piece === pieces.white.king;
            const kingMoved = isWhiteKing ? gameState.whiteKingMoved : gameState.blackKingMoved;
            if (!kingMoved && !isSquareUnderAttack(row, col, !isWhite, board)) {
                if (isWhiteKing && row === 7 && col === 4) {
                    if (!gameState.whiteRookRightMoved &&
                        board[7][5] === '' && board[7][6] === '' &&
                        !isSquareUnderAttack(7, 5, false, board) &&
                        !isSquareUnderAttack(7, 6, false, board)) {
                        moves.push({ row: 7, col: 6 });
                    }
                    if (!gameState.whiteRookLeftMoved &&
                        board[7][1] === '' && board[7][2] === '' && board[7][3] === '' &&
                        !isSquareUnderAttack(7, 3, false, board) &&
                        !isSquareUnderAttack(7, 2, false, board)) {
                        moves.push({ row: 7, col: 2 });
                    }
                } else if (!isWhiteKing && row === 0 && col === 4) {
                    if (!gameState.blackRookRightMoved &&
                        board[0][5] === '' && board[0][6] === '' &&
                        !isSquareUnderAttack(0, 5, true, board) &&
                        !isSquareUnderAttack(0, 6, true, board)) {
                        moves.push({ row: 0, col: 6 });
                    }
                    if (!gameState.blackRookLeftMoved &&
                        board[0][1] === '' && board[0][2] === '' && board[0][3] === '' &&
                        !isSquareUnderAttack(0, 3, true, board) &&
                        !isSquareUnderAttack(0, 2, true, board)) {
                        moves.push({ row: 0, col: 2 });
                    }
                }
            }
        }

        const legalMoves = moves.filter(move => {
            return !wouldBeInCheck(row, col, move.row, move.col, isWhite);
        });
        return legalMoves;
    }

    function wouldBeInCheck(fromRow, fromCol, toRow, toCol, isWhite) {
        const tempBoard = gameState.board.map(row => [...row]);
        tempBoard[toRow][toCol] = tempBoard[fromRow][fromCol];
        tempBoard[fromRow][fromCol] = '';
        const kingPiece = isWhite ? pieces.white.king : pieces.black.king;
        let kingRow, kingCol;
        for (let r = 0; r < 8; r++) {
            for (let c = 0; c < 8; c++) {
                if (tempBoard[r][c] === kingPiece) {
                    kingRow = r;
                    kingCol = c;
                    break;
                }
            }
            if (kingRow !== undefined) break;
        }
        return isSquareUnderAttack(kingRow, kingCol, !isWhite, tempBoard);
    }

    function isSquareUnderAttack(row, col, byWhite, board) {
        const opponentPieces = byWhite ? Object.values(pieces.white) : Object.values(pieces.black);
        for (let r = 0; r < 8; r++) {
            for (let c = 0; c < 8; c++) {
                const piece = board[r][c];
                if (opponentPieces.includes(piece)) {
                    const moves = getRawMoves(r, c, piece, board);
                    if (moves.some(m => m.row === row && m.col === col)) {
                        return true;
                    }
                }
            }
        }
        return false;
    }

    function getRawMoves(row, col, piece, board) {
        const moves = [];
        const isWhite = Object.values(pieces.white).includes(piece);

        if (piece === pieces.white.pawn || piece === pieces.black.pawn) {
            const direction = isWhite ? -1 : 1;
            [-1, 1].forEach(dc => {
                const captureRow = row + direction;
                const captureCol = col + dc;
                if (isValidSquare(captureRow, captureCol)) {
                    moves.push({ row: captureRow, col: captureCol });
                }
            });
        } else if (piece === pieces.white.rook || piece === pieces.black.rook) {
            addLineMoves(row, col, [[0,1], [0,-1], [1,0], [-1,0]], moves, isWhite, board);
        } else if (piece === pieces.white.bishop || piece === pieces.black.bishop) {
            addLineMoves(row, col, [[1,1], [1,-1], [-1,1], [-1,-1]], moves, isWhite, board);
        } else if (piece === pieces.white.queen || piece === pieces.black.queen) {
            addLineMoves(row, col, [
                [0,1], [0,-1], [1,0], [-1,0],
                [1,1], [1,-1], [-1,1], [-1,-1]
            ], moves, isWhite, board);
        } else if (piece === pieces.white.knight || piece === pieces.black.knight) {
            const knightMoves = [
                [-2,-1], [-2,1], [-1,-2], [-1,2],
                [1,-2], [1,2], [2,-1], [2,1]
            ];
            knightMoves.forEach(([dr, dc]) => {
                const newRow = row + dr;
                const newCol = col + dc;
                if (isValidSquare(newRow, newCol)) {
                    moves.push({ row: newRow, col: newCol });
                }
            });
        } else if (piece === pieces.white.king || piece === pieces.black.king) {
            const kingMoves = [
                [-1,-1], [-1,0], [-1,1],
                [0,-1], [0,1],
                [1,-1], [1,0], [1,1]
            ];
            kingMoves.forEach(([dr, dc]) => {
                const newRow = row + dr;
                const newCol = col + dc;
                if (isValidSquare(newRow, newCol)) {
                    moves.push({ row: newRow, col: newCol });
                }
            });
        }
        return moves;
    }

    function addLineMoves(row, col, directions, moves, isWhite, board) {
        directions.forEach(([dr, dc]) => {
            let newRow = row + dr;
            let newCol = col + dc;
            while (isValidSquare(newRow, newCol)) {
                const target = board[newRow][newCol];
                if (!target) {
                    moves.push({ row: newRow, col: newCol });
                } else {
                    if (isOpponentPiece(target, isWhite)) {
                        moves.push({ row: newRow, col: newCol });
                    }
                    break;
                }
                newRow += dr;
                newCol += dc;
            }
        });
    }

    function isValidSquare(row, col) {
        return row >= 0 && row < 8 && col >= 0 && col < 8;
    }

    function isOpponentPiece(piece, isWhitePlayer) {
        const whitePieces = Object.values(pieces.white);
        const blackPieces = Object.values(pieces.black);
        if (isWhitePlayer) {
            return blackPieces.includes(piece);
        } else {
            return whitePieces.includes(piece);
        }
    }

    function resetGame() {
        if (!confirm('Reset the game?')) return;
        gameState.board = getInitialBoard();
        gameState.currentTurn = 'white';
        Object.assign(gameState, createInitialCastlingState());
        isGameOver = false;
        selectedSquare = null;
        possibleMoves = [];
        if (timedGame) {
            whiteTimeMs = timePerMinutes * 60 * 1000;
            blackTimeMs = timePerMinutes * 60 * 1000;
        } else {
            whiteTimeMs = 0;
            blackTimeMs = 0;
        }
        stopClock();
        if (connection && connection.open) {
            connection.send({ type: 'reset' });
        }
        updateGameUI();
        if (timedGame) startClockForCurrentTurn();
        showStatus('Game reset!');
    }

    function leaveGame(fromDisconnect = false) {
        stopClock();
        if (connection && connection.open && !fromDisconnect) {
            connection.close();
        }
        if (peer) {
            peer.destroy();
        }
        selectedSquare = null;
        possibleMoves = [];
        gameState = null;
        isGameOver = false;
        timedGame = false;
        timePerMinutes = 0;
        whiteTimeMs = 0;
        blackTimeMs = 0;

        if (playerRef) {
            playerRef.update({ inGame: false });
        }

        document.getElementById('gameScreen').classList.add('hidden');
        document.getElementById('waitingScreen').classList.add('hidden');
        document.getElementById('lobbyScreen').classList.remove('hidden');
        document.getElementById('joinForm').classList.add('hidden');
        document.getElementById('roomCodeInput').value = '';
        closeWinnerModal();
        closeLoserModal();
    }

    function cancelWaiting() {
        if (peer) {
            peer.destroy();
        }
        if (playerRef) {
            playerRef.update({ inGame: false });
        }
        document.getElementById('waitingScreen').classList.add('hidden');
        document.getElementById('lobbyScreen').classList.remove('hidden');
    }

    function copyRoomCode() {
        const code = document.getElementById('roomCodeDisplay').textContent;
        navigator.clipboard.writeText(code).then(() => {
            showStatus('Room code copied!');
        }).catch(() => {
            showStatus('Failed to copy code!', true);
        });
    }

    function showStatus(message, isError = false) {
        const statusDiv = document.getElementById('statusMessage');
        statusDiv.textContent = message;
        statusDiv.className = 'status-message';
        if (isError) statusDiv.classList.add('error');
        statusDiv.classList.remove('hidden');
        setTimeout(() => statusDiv.classList.add('hidden'), 3000);
    }

    function openWinnerModal() {
        const overlay = document.getElementById('winnerOverlay');
        const info = document.getElementById('winnerModalInfo');
        info.textContent = '';
        overlay.classList.remove('hidden');
    }

    function closeWinnerModal() {
        document.getElementById('winnerOverlay').classList.add('hidden');
    }

    function openLoserModal() {
        document.getElementById('loserOverlay').classList.remove('hidden');
    }

    function closeLoserModal() {
        document.getElementById('loserOverlay').classList.add('hidden');
    }

    function sendRematchOffer() {
        if (!lastWinnerName) return;
        const info = document.getElementById('winnerModalInfo');
        info.textContent = 'Rematch offer sent. Waiting for opponent response.';
        if (connection && connection.open) {
            connection.send({
                type: 'rematchOffer',
                winnerName: lastWinnerName
            });
        }
    }

    function respondRematch(accepted) {
        if (!pendingRematchFromWinner) {
            closeLoserModal();
            return;
        }
        if (connection && connection.open) {
            connection.send({
                type: 'rematchResponse',
                accepted: accepted,
                winnerName: pendingRematchFromWinner
            });
        }
        if (!accepted) {
            closeLoserModal();
            showStatus('You declined the rematch.');
        } else {
            startNewRound(pendingRematchFromWinner, true);
            closeLoserModal();
        }
        pendingRematchFromWinner = null;
    }

    function handleRematchResponse(accepted, winnerName) {
        const info = document.getElementById('winnerModalInfo');
        if (!accepted) {
            info.textContent = 'Opponent declined the rematch.';
            return;
        }
        startNewRound(winnerName, false);
        closeWinnerModal();
    }

    function startNewRound(winnerName, isLocalInitiator) {
        let whiteName, blackName;
        if (winnerName === gameState.white) {
            whiteName = gameState.white;
            blackName = gameState.black;
        } else {
            whiteName = gameState.black;
            blackName = gameState.white;
        }
        gameState.white = whiteName;
        gameState.black = blackName;
        gameState.board = getInitialBoard();
        gameState.currentTurn = 'white';
        myColor = (currentPlayer === whiteName) ? 'white' : 'black';

        const keepTimed = !!gameState.timedGame;
        const keepMinutes = gameState.timeMinutes || 0;
        timedGame = keepTimed;
        timePerMinutes = keepMinutes;
        gameState.timedGame = timedGame;
        gameState.timeMinutes = timePerMinutes;

        if (timedGame) {
            whiteTimeMs = timePerMinutes * 60 * 1000;
            blackTimeMs = timePerMinutes * 60 * 1000;
            gameState.whiteTimeMs = whiteTimeMs;
            gameState.blackTimeMs = blackTimeMs;
        } else {
            whiteTimeMs = 0;
            blackTimeMs = 0;
            gameState.whiteTimeMs = 0;
            gameState.blackTimeMs = 0;
        }

        Object.assign(gameState, createInitialCastlingState());
        isGameOver = false;
        selectedSquare = null;
        possibleMoves = [];
        stopClock();

        if (isLocalInitiator && connection && connection.open) {
            connection.send({
                type: 'newRound',
                whiteName: whiteName,
                blackName: blackName,
                timedGame: timedGame,
                timeMinutes: timePerMinutes
            });
        }

        showStatus('New round started!');
        updateGameUI();
        if (timedGame) startClockForCurrentTurn();
    }

    function startClockForCurrentTurn() {
        if (!timedGame || isGameOver) return;
        stopClock();
        lastTickTime = Date.now();
        activeTimer = setInterval(tickClock, 200);
    }

    function stopClock() {
        if (activeTimer) {
            clearInterval(activeTimer);
            activeTimer = null;
        }
        lastTickTime = null;
    }

    function tickClock() {
        if (!timedGame || isGameOver) {
            stopClock();
            return;
        }
        const now = Date.now();
        const delta = now - (lastTickTime || now);
        lastTickTime = now;

        if (gameState.currentTurn === 'white') {
            whiteTimeMs -= delta;
            if (whiteTimeMs <= 0) {
                whiteTimeMs = 0;
                updateGameUI();
                stopClock();
                handleTimeOver('white');
                return;
            }
        } else {
            blackTimeMs -= delta;
            if (blackTimeMs <= 0) {
                blackTimeMs = 0;
                updateGameUI();
                stopClock();
                handleTimeOver('black');
                return;
            }
        }
        updateGameUI();
    }

    function updateTimeForCurrentTurn() {
        if (!timedGame || !lastTickTime) return;
        const now = Date.now();
        const delta = now - lastTickTime;
        lastTickTime = now;
        if (gameState.currentTurn === 'white') {
            whiteTimeMs -= delta;
            if (whiteTimeMs < 0) whiteTimeMs = 0;
        } else {
            blackTimeMs -= delta;
            if (blackTimeMs < 0) blackTimeMs = 0;
        }
    }

    function handleTimeOver(loserColor) {
        if (isGameOver) return;
        const winnerColor = loserColor === 'white' ? 'black' : 'white';
        const winnerName = winnerColor === 'white' ? gameState.white : gameState.black;
        lastWinnerName = winnerName;
        if (connection && connection.open) {
            connection.send({
                type: 'gameOver',
                winnerColor: winnerColor,
                winnerName: winnerName
            });
        }
        handleGameOver(winnerColor, true);
        showStatus('Time is over. Loss on time.', true);
    }

    function formatTime(ms) {
        if (ms < 0) ms = 0;
        const totalSeconds = Math.floor(ms / 1000);
        const minutes = Math.floor(totalSeconds / 60);
        const seconds = totalSeconds % 60;
        const mStr = minutes.toString().padStart(2, '0');
        const sStr = seconds.toString().padStart(2, '0');
        return `${mStr}:${sStr}`;
    }

    function showPromotionModal(isWhite) {
        const overlay = document.getElementById('promotionOverlay');
        const queenEl = document.getElementById('promotionQueen');
        const rookEl = document.getElementById('promotionRook');
        const bishopEl = document.getElementById('promotionBishop');
        const knightEl = document.getElementById('promotionKnight');

        if (isWhite) {
            queenEl.textContent = pieces.white.queen;
            rookEl.textContent = pieces.white.rook;
            bishopEl.textContent = pieces.white.bishop;
            knightEl.textContent = pieces.white.knight;
            queenEl.className = 'promotion-piece white';
            rookEl.className = 'promotion-piece white';
            bishopEl.className = 'promotion-piece white';
            knightEl.className = 'promotion-piece white';
        } else {
            queenEl.textContent = pieces.black.queen;
            rookEl.textContent = pieces.black.rook;
            bishopEl.textContent = pieces.black.bishop;
            knightEl.textContent = pieces.black.knight;
            queenEl.className = 'promotion-piece black';
            rookEl.className = 'promotion-piece black';
            bishopEl.className = 'promotion-piece black';
            knightEl.className = 'promotion-piece black';
        }

        overlay.classList.remove('hidden');
    }

    function closePromotionModal() {
        document.getElementById('promotionOverlay').classList.add('hidden');
    }

    function selectPromotion(pieceType) {
        if (!pendingPromotion) return;
        
        closePromotionModal();
        
        const { fromRow, fromCol, toRow, toCol } = pendingPromotion;
        pendingPromotion = null;
        
        makeMove(fromRow, fromCol, toRow, toCol, pieceType);
    }
</script>
</body>
</html>